data {
  int<lower=1>    K; // number of individuals
  int<lower=1>    N; // number of observations
  matrix[N,K]     Z; // Random effects design matrix
  matrix[K,K]     Z2; // Random effects design matrix2
  vector[N]       Y; // response variable
   matrix[K,K]     A; // relationship matrix
}

transformed data{
  matrix[K,K] LA;
  LA = cholesky_decompose(A);
}

parameters {
  vector[K]  a_decompose; // standardized breeding values
  vector[K]  a_decompose2; // standardized breeding values
  
  vector[K] I; // individual deviations 
  vector[K] I2b; // individual deviations 
  
  real b1; //mean of observed trait
  real b2; //mean of observed trait

  real<lower=0> sigma_I; // Individual standard deviation
  real<lower=0> sigma_R; // residual standard deviation
  real<lower=0> sigma_R2; // residual standard deviation
 
  real<lower=0> sigma_G; // genetic standard deviation for squared values
  real<lower=0> sigma_I2; // environment standard deviation for sq values
}

transformed parameters{
  vector[K] I2; // squared of individual deviations
  for(j in 1:K){ // Calculate squared values of the mean deviations
  I2[j] =  I[j];  
   }
}

model {
vector[N] mu1; // expected observation values
vector[N] mu2; // expected squared values
vector[K] muI2; // expected mean squared values
vector[K] a;  // breeding values for squared individual values
vector[K] a2;  // breeding values for squared individual values

a = sigma_G * (LA * a_decompose);
a2 = sigma_G2 * (LA * a_decompose2);

target += normal_lpdf(a_decompose  | 0, 1); 
target += normal_lpdf(a_decompose2  | 0, 1); 

target += normal_lpdf(I  | 0, sigma_I);   

mu1 = b1 + Z*a + Z*I; // Effect of the individual average on phenotype expression
muI2 =  b2 + Z2*a2;  // Effect of a on the average squared deviation

target += normal_lpdf(Y  | mu1, sigma_R);   //model for phenotype
target += normal_lpdf(I2  | muI2, sigma_I2); //model for squared

//Priors
b1~normal(0,1);
b2~normal(0,1);

target +=inv_gamma_lpdf( sigma_I  | 1, 1);
target +=inv_gamma_lpdf( sigma_R  | 1, 1);
target +=inv_gamma_lpdf( sigma_R2  | 1, 1);

target += inv_gamma_lpdf( sigma_G  | 1, 1);
target += inv_gamma_lpdf( sigma_G2  | 1, 1);
target +=inv_gamma_lpdf( sigma_I2  | 1, 1);
 
}

generated quantities{
  real sigma2_G;
  real sigma2_E; 
  real sigma2_I;
  
  sigma2_G = sigma_G*sigma_G;
  sigma2_I = sigma_I * sigma_I; // individual variance
  sigma2_E = sigma_R * sigma_R; // residual variance
}
